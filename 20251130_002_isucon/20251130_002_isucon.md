# ISUCON(2)基礎的な負荷試験

今回から本格的にISUCONトレーニングの記録を綴っていきます。
まずは書籍「達人が教えるWebパフォーマンスチューニング」を読みながら
実際に手を動かして体験していこうと思います。
今回は「Chapter3 基礎的な負荷試験」までで学習したことを綴っていきます。
書籍の内容すべてを書き残すわけでなく個人的に残しておきたいノウハウに
ついてのみまとめます。
また、私の環境ではDockerを用いて検証するため、その点での差異になども
書き残していきたいと思います。


## 検証環境

まず前提となる私の検証環境ですがPCはインテルCPUのMac Book Proです。
「達人が教えるWebパフォーマンスチューニング」に記載の実際にパフォーマンス改善を
行うWebアプリケーション、private-isuはMac内にDocker環境を構築し検証していきます。

検証用のPCと検証対象のWebアプリケーションが同じホスト上で動くと互いにリソースを
共有し、環境としては理想的ではないため、いずれ検証対象のアプリケーションを
別で動かすためのサーバーを用意したいと思っていますが、一旦はこの構成で進めます。


## 基本的な用語

計測やパフォーマンスチューニングを始める前に基本的な用語の整理をします。
チューニングにおいて頻出の2つの単語「レイテンシ」と「スループット」について整理します。
ここでの単語の扱いはWebの文脈においてとなります。

### レイテンシ

クライアントがリクストを送信開始しレスポンスを受信完了するまでにかかる時間です。
レスポンスタイムともいいます。
レイテンシの単位はmsec、μsecが多く、この値が低ければ低いほど良いということになります。

### スループット

単位時間あたりに処理できるリクエスト数を示す値です。
同時並行処理性能を表します。
1秒間にどれだけのリクエストを処理できるかを表したrps(request per second)を単位とします。
この値が多ければ多いほど良いということになります。

## 計測ツール

Chapter3では以下の2つのツールを主に使用し計測します。

- alp
- ab

### alp

Webサーバーのログを入力に読みやすく加工してくれるCLIツールです。
正式名称はAccess Log Profiler。
実行イメージは以下です。

```
tail -n 50 ./logs/nginx/access.log  | alp json -o count,method,uri,min,avg,max

+-------+--------+---------------------------------------------------+-------+-------+-------+
| COUNT | METHOD |                        URI                        |  MIN  |  AVG  |  MAX  |
+-------+--------+---------------------------------------------------+-------+-------+-------+
| 1     | GET    | /favicon.ico                                      | 0.004 | 0.004 | 0.004 |
| 2     | GET    | /css/style.css                                    | 0.004 | 0.050 | 0.095 |
| 2     | GET    | /img/ajax-loader.gif                              | 0.029 | 0.037 | 0.046 |
| 2     | GET    | /js/main.js                                       | 0.074 | 0.079 | 0.084 |
| 2     | GET    | /js/timeago.min.js                                | 0.069 | 0.082 | 0.095 |
| 6     | GET    | /.well-known/appspecific/com.chrome.devtools.json | 0.002 | 0.033 | 0.076 |
```

### ab

外部から任意のURLに負荷検証するためにリクエストを送信するCLIツールです。
正式名称はApache Bench。
リクエスト後にレイテンシやスループットなどの情報をまとめて表示します。
コマンド実行イメージは以下です。

```
ab -c 1 -t 30 http://localhost/
```

## 計測の下準備

### フォーマットの変更

nginxのアクセスログなど、デフォルトでは解析しづらいフォーマットになっているため、
jsonなどの処理しやすいフォーマットに変更します。
設定は`webapp/etc/nginx/conf.d/default.conf`に追加します。

### ローテートの準備

ログは計測ごとに分けておきたいですが、デフォルトのnginxのアクセスログでは一つの
ログにどんどん追記されていきます。そのため、計測ごとにログを別名にし分けておきます。
この作業をローテートといいます。
以下のように日時を付与して都度ログを分けます。

```
mv ./access.log ./access.`date +%Y%m%d-%H%M%S`
```

nginx の access.log はファイル名を変えても書き込み先が変化しません。
変更するには色々な方法がありますが、nginxのmasterプロセスにシグナル送信するのが手軽です。

```
# nginxコンテナで実行
/usr/sbin/nginx -s reopen
```

### マウントする(Dockerの場合)

Docker環境の場合はホストでログを操作しやすいよう、`access.log`をマウントすると良いです。

## 手始めのあたりの付け方

手始めに特定のエンドポイントに対して`ab`で負荷を与えます。
このとき、`top`コマンドでサーバーのCPU負荷状況を観測し、リソースの使用が激しいプロセス
を調べます。リソースの消費が激しいということはボトルネックとなっている可能性が高いということになります。

今回はDocker環境で構築しているため、Webサーバー、アプリケーションサーバー、データベース
それぞれのコンテナでのリソース消費状況を観測することで負荷の高いコンテナを見極めます。
`docker stats`コマンドで各コンテナのリソース消費状況を観測できます。

以上を用いて`http://localhost/`に負荷を与えるとデータベースコンテナ(`mysql`)が
著しくCPUを使用していることがわかります。
手始めにデータベースが改善対象にということになりました。

## データベース改善

データベースが怪しいとなった場合、次にやることとしてはデータベースのボトルネックを
発見する準備です。

### スロークエリを設定する

まずはスロークエリログを設定します。
ここで重要なのがクエリログ出力対象とするしきい値に0秒を設定することです。
これは1つ1つのクエリの実行時間が短くてもクエリ回数が多いことによって、
時間がかかっているクエリを発見するためです。

取得したスロークエリログはそのままでは数が多く見づらいため、
`mysqldumpshow`コマンドを使用することで要約された見やすい出力となります。

```
mysqldumpslow mysql-slow.log
```

### MySQLのログローテート

MySQLのログもローテートする場合は以下のコマンドが必要です。

```
mysqladmin flush-logs
```

### データベース解析ポイント

ログが取得できたらデータベースの問題箇所を洗い出します。
主な観点は以下になります。

#### ①スロークエリを解析する

- Rows_sent : 実際にクライアントに返した行数
- Rows_examined : 内部で処理した行数

この差が大きいと、非効率な可能性が高い。

#### ②テーブルの構成を確認する

インデックスが適切に設定されているか等確認。

```
SHOW CREATE TABLE table_name;
```

#### ③ EXPLAIN でクエリの実行計画を確認する

インデックスが使われているか？
rows で走査される行数は多くないか？


## ワーカープロセス数改善

次に書籍ではアプリケーションのワーカープロセス数を上げる改善を施しますが、
その際の、Docker環境での調査方法の覚書を残します。
まず、`dstat`コマンド。これは`docker stats`を用いて以下のシェルスクリプトを
作成することにより代替しました。

```
# 1秒ごとに一度、データを取得し、ファイルに追記（ログとして記録）
while true; do
  docker stats --no-stream --format "{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" | sed 's/\r//g' >> docker_cpu_log.txt
  sleep 1
done
 
```

また、`systemctl status isu-ruby`もコンテナ環境にはないため`docker compose top app`で代用しました。

```
$ docker compose top app
SERVICE  #   UID   PID  PPID  C   STIME  TTY  TIME      CMD
app      1   root  751  728   0   08:47  ?    00:00:00  /sbin/docker-init -- bundle exec unicorn -c unicorn_config.rb
app      1   root  774  751   0   08:47  ?    00:00:01  unicorn master -c unicorn_config.rb
app      1   root  945  774   0   08:47  ?    00:01:06  unicorn worker[0] -c unicorn_config.rb
```


docker環境でunicornのワーカープロセス数を増やすにはdocker-compose.ymlの
appサービスにある deploy.resources.limits.cpu を "4" に設定してから、
`unicorn_config.rb` の worker_processes を4に増やす必要もあります。

## まとめ

第二回は書籍の「基礎的な負荷試験」までの内容について、
Docker環境での代替方法と個人的な重要ポイントをまとめました。
次回は続きの「Chapter4 シナリオを持った負荷試験」からまた続けていきたいと思います。
